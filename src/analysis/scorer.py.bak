import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, Optional, List
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class ScoreResult:
    ticker: str
    total_score: float
    signal_strength: str  # "STRONG_BUY", "BUY", "NEUTRAL", "SELL"
    breakdown: Dict[str, float]
    risk_flags: List[str]
    strategy_name: str = "Unknown"

class BaseScorer(ABC):
    """
    Abstract base class for stock scoring strategies.
    Extend this to create new scoring strategies for backtesting.
    """
class BaseScorer(ABC):
    """
    Abstract base class for stock scoring strategies.
    Extend this to create new scoring strategies for backtesting.
    """
    
    def __init__(self, strategy_name: str = "Base"):
        self.strategy_name = strategy_name
        self.weights = self._get_weights()
    
    @abstractmethod
    def _get_weights(self) -> Dict[str, float]:
        """Return the component weights for this strategy."""
        pass
    
    @abstractmethod
    def _calc_technical_score(self, row: pd.Series, df_features: pd.DataFrame) -> float:
        """Calculate technical analysis score (0-100)."""
        pass
    
    @abstractmethod
    def _calc_institutional_score(self, df_trades: pd.DataFrame, current_date: pd.Timestamp) -> float:
        """Calculate institutional flow score (0-100)."""
        pass
    
    @abstractmethod
    def _calc_fundamental_score(self, df_fins: pd.DataFrame) -> float:
        """Calculate fundamental analysis score (0-100)."""
        pass
    
    @abstractmethod
    def _calc_volatility_score(self, row: pd.Series, df_features: pd.DataFrame) -> float:
        """Calculate volatility/risk score (0-100)."""
        pass
    
    def evaluate(self, 
                 ticker: str,
                 df_features: pd.DataFrame, 
                 df_trades: pd.DataFrame, 
                 df_financials: pd.DataFrame,
                 metadata: dict) -> ScoreResult:
        """
        Main entry point to calculate the score for a single ticker.
        This orchestration logic is shared across all strategies.
        """
        # 1. Sanity Check
        if df_features.empty:
            return self._empty_result(ticker, "No Price Data")

        # Get latest data points
        latest_row = df_features.iloc[-1]
        current_date = pd.to_datetime(latest_row['Date'])

        # --- A. Technical Scoring (0-100) ---
        tech_score = self._calc_technical_score(latest_row, df_features)

        # --- B. Institutional Flow Scoring (0-100) ---
        inst_score = self._calc_institutional_score(df_trades, current_date)

        # --- C. Fundamental Scoring (0-100) ---
        fund_score = self._calc_fundamental_score(df_financials)

        # --- D. Volatility/Risk Scoring (0-100) ---
        vol_score = self._calc_volatility_score(latest_row, df_features)

        # --- E. Risk Checks ---
        risk_flags = []
        earnings_penalty = self._check_earnings_risk(metadata, current_date, risk_flags)

        # --- Final Calculation ---
        total_score = (
            tech_score * self.weights["technical"] +
            inst_score * self.weights["institutional"] +
            fund_score * self.weights["fundamental"] +
            vol_score * self.weights["volatility"]
        )
        
        # Apply earnings penalty
        total_score *= earnings_penalty

        signal = self._interpret_score(total_score, risk_flags)

        return ScoreResult(
            ticker=ticker,
            total_score=round(total_score, 2),
            signal_strength=signal,
            breakdown={
                "Technical": round(tech_score, 1),
                "Institutional": round(inst_score, 1),
                "Fundamental": round(fund_score, 1),
                "Volatility": round(vol_score, 1)
            },
            risk_flags=risk_flags,
            strategy_name=self.strategy_name
        )
    
    def _check_earnings_risk(self, metadata: dict, current_date: pd.Timestamp, risk_flags: List[str]) -> float:
        """
        Check earnings proximity and return penalty multiplier (0.0-1.0).
        Subclasses can override for different risk handling.
        """
        if not metadata or 'earnings_calendar' not in metadata:
            return 1.0
            
        for event in metadata['earnings_calendar']:
            try:
                evt_date = pd.to_datetime(event['Date'])
                delta = (evt_date - current_date).days
                if 0 <= delta <= 7:
                    risk_flags.append("EARNINGS_APPROACHING")
                    return 0.7  # Default 30% penalty
            except:
                continue
        return 1.0
    
    def _interpret_score(self, score: float, risk_flags: List[str]) -> str:
        """Interpret numerical score into trading signal."""
        if "EARNINGS_APPROACHING" in risk_flags and score < 75:
            return "HOLD/WAIT"
            
        if score >= 80:
            return "STRONG_BUY"
        elif score >= 65:
            return "BUY"
        elif score <= 35:
            return "STRONG_SELL"
        elif score <= 45:
            return "SELL"
        else:
            return "NEUTRAL"
    
    def _empty_result(self, ticker: str, reason: str) -> ScoreResult:
        return ScoreResult(
            ticker=ticker,
            total_score=0.0,
            signal_strength="ERROR",
            breakdown={},
            risk_flags=[reason],
            strategy_name=self.strategy_name
        )


# ============================================================================
# STRATEGY 1: Simple Scorer (Original Logic)
# ============================================================================

class SimpleScorer(BaseScorer):
    """
    Original simple scoring strategy.
    - Technical: 40%, Institutional: 30%, Fundamental: 20%, Volatility: 10%
    - Uses only Foreign investor flow
    - Basic fundamental metrics (Sales, OP growth)
    - Simplified volatility check
    """
    
    def __init__(self):
        super().__init__(strategy_name="Simple_v1")
    
    def _get_weights(self) -> Dict[str, float]:
        return {
            "technical": 0.4,
            "institutional": 0.3,
            "fundamental": 0.2,
            "volatility": 0.1
        }
    
    def _check_earnings_risk(self, metadata: dict, current_date: pd.Timestamp, risk_flags: List[str]) -> float:
        """Original: penalizes technical score heavily (50% cut on total via 0.5 on tech component)."""
        if not metadata or 'earnings_calendar' not in metadata:
            return 1.0
            
        for event in metadata['earnings_calendar']:
            try:
                evt_date = pd.to_datetime(event['Date'])
                delta = (evt_date - current_date).days
                if 0 <= delta <= 7:
                    risk_flags.append("EARNINGS_APPROACHING")
                    # Original logic: 50% penalty on technical (40% weight) = ~20% total penalty
                    return 0.8
            except:
                continue
        return 1.0
    
    def _calc_technical_score(self, row: pd.Series, df_features: pd.DataFrame) -> float:
        score = 50.0 # Start neutral

        # 1. Trend Alignment (The "Perfect Order")
        # Bullish: Price > EMA20 > EMA50 > EMA200
        if row['Close'] > row['EMA_20'] > row['EMA_50'] > row['EMA_200']:
            score += 20
        elif row['Close'] > row['EMA_200']:
            score += 10
        elif row['Close'] < row['EMA_200']:
            score -= 20 # Bear market penalty

        # 2. RSI Logic (Reversion vs Momentum)
        rsi = row['RSI']
        if 40 <= rsi <= 65:
            score += 10 # Healthy trend
        elif rsi > 75:
            score -= 10 # Overbought Risk
        elif rsi < 30:
            score += 5  # Oversold bounce potential (risky but valid)

        # 3. MACD Momentum
        # Histogram > 0 and expanding is bullish
        if row['MACD_Hist'] > 0:
            score += 10
            if row['MACD'] > 0: # Above zero line
                score += 5
        
        return np.clip(score, 0, 100)

    def _calc_institutional_score(self, df_trades: pd.DataFrame, current_date: pd.Timestamp) -> float:
        """
        Analyzes RAW_TRADES (Weekly). Focuses on Foreign Investors (FrgnBal).
        """
        if df_trades.empty:
            return 50.0 # Neutral if no data

        # Convert dates to ensure we look at recent past
        df_trades['EnDate'] = pd.to_datetime(df_trades['EnDate'])
        
        # Look back 4 weeks
        mask = (df_trades['EnDate'] <= current_date) & (df_trades['EnDate'] >= current_date - timedelta(days=35))
        recent_trades = df_trades.loc[mask].sort_values('EnDate')

        if recent_trades.empty:
            return 50.0

        score = 50.0
        
        # KEY METRIC: Cumulative Foreign Balance (Net Buying)
        # Assuming 'FrgnBal' is the Net Buy/Sell for that week
        net_foreign_flow = recent_trades['FrgnBal'].sum()
        
        if net_foreign_flow > 0:
            score += 20 # Foreigners are buying
            # Bonus: If buying is accelerating (Last week > Avg)
            if recent_trades.iloc[-1]['FrgnBal'] > recent_trades['FrgnBal'].mean():
                score += 10
        else:
            score -= 20 # Foreigners are dumping

        return np.clip(score, 0, 100)

    def _calc_fundamental_score(self, df_fins: pd.DataFrame) -> float:
        """
        Analyzes RAW_FINANCIALS. Focuses on Growth (Sales/OP).
        """
        if df_fins.empty or len(df_fins) < 2:
            return 50.0 # Need at least 2 quarters to compare

        # Sort by report date
        df_fins = df_fins.sort_values('DiscDate')
        latest = df_fins.iloc[-1]
        prev = df_fins.iloc[-2]

        score = 50.0

        # Convert to numeric (columns are stored as strings)
        latest_sales = pd.to_numeric(latest['Sales'], errors='coerce')
        prev_sales = pd.to_numeric(prev['Sales'], errors='coerce')
        latest_op = pd.to_numeric(latest['OP'], errors='coerce')
        prev_op = pd.to_numeric(prev['OP'], errors='coerce')

        # Revenue Growth Check
        if pd.notna(latest_sales) and pd.notna(prev_sales) and latest_sales > prev_sales:
            score += 15
        
        # Operating Profit Growth Check
        if pd.notna(latest_op) and pd.notna(prev_op) and latest_op > prev_op:
            score += 15
            
        # Profit Margin Expansion
        try:
            if latest_sales > 0 and prev_sales > 0:
                latest_margin = latest_op / latest_sales
                prev_margin = prev_op / prev_sales
                if latest_margin > prev_margin:
                    score += 10
        except (ZeroDivisionError, TypeError):
            pass

        return np.clip(score, 0, 100)

    def _calc_volatility_score(self, row: pd.Series, df_features: pd.DataFrame) -> float:
        """
        Uses ATR and Volume to determine stability (original simplified version).
        """
        score = 50.0
        
        # Volume Liquidity Check
        if row['Volume'] > row['Volume_SMA_20']:
            score += 10
        
        # ATR Check (Simplified) - original didn't actually use ATR
        # If price is far above EMA20 (extended), penalize
        deviation = (row['Close'] - row['EMA_20']) / row['EMA_20']
        if deviation > 0.05:
            score -= 10
            
        return np.clip(score, 0, 100)


# ============================================================================
# STRATEGY 2: Enhanced Scorer (Japan-Optimized)
# ============================================================================

class EnhancedScorer(BaseScorer):
    """
    Enhanced scoring strategy optimized for Japanese stock market.
    
    KEY IMPROVEMENTS:
    1. Institutional: Smart money composite (Foreign + TrustBank + InvTrust + Insurance)
       vs Dumb money divergence detection
    2. Fundamental: EPS growth, forecast beats, cash flow quality, balance sheet health
    3. Volatility: Proper ATR historical comparison (as originally intended)
    4. Earnings Risk: Progressive penalty based on days until earnings
    5. Weights: 35% Tech, 35% Institutional (increased), 20% Fund, 10% Vol
    
    JAPANESE MARKET SPECIFICS:
    - Foreign investors are trend leaders in Japan (30% of volume)
    - Retail investors are contrarian (fade them at extremes)
    - Conservative guidance culture → forecast beats are strong signals
    - Lower volatility than US → ATR regimes matter more
    - Earnings gaps can be brutal (5-15%) → stricter risk management
    """
    
    def __init__(self):
        super().__init__(strategy_name="Enhanced_Japan_v1")
    
    def _get_weights(self) -> Dict[str, float]:
        return {
            "technical": 0.35,      # Reduced from 40% (Japan less technical than US)
            "institutional": 0.35,  # Increased from 30% (institutions drive Japan market)
            "fundamental": 0.20,    # Unchanged but better utilization
            "volatility": 0.10      # Unchanged but properly calculated now
        }
    
    def _check_earnings_risk(self, metadata: dict, current_date: pd.Timestamp, risk_flags: List[str]) -> float:
        """
        Progressive earnings risk penalty based on days until release.
        Japanese stocks gap violently on earnings surprises.
        """
        if not metadata or 'earnings_calendar' not in metadata:
            return 1.0
            
        for event in metadata['earnings_calendar']:
            try:
                evt_date = pd.to_datetime(event['Date'])
                delta = (evt_date - current_date).days
                
                if delta < 0:
                    continue  # Past earnings
                elif delta == 0 or delta == 1:
                    risk_flags.append("EARNINGS_IMMINENT")
                    return 0.5  # 50% penalty (within 24-48 hours)
                elif delta <= 3:
                    risk_flags.append("EARNINGS_APPROACHING")
                    return 0.7  # 30% penalty (2-3 days)
                elif delta <= 7:
                    risk_flags.append("EARNINGS_NEAR")
                    return 0.85  # 15% penalty (4-7 days)
            except:
                continue
        return 1.0
    
    def _calc_technical_score(self, row: pd.Series, df_features: pd.DataFrame) -> float: